#!/bin/bash

#exec 3>&1 4>&2
#trap 'exec 2>&4 1>&3' 0 1 2 3
#exec 1>log.out 2>&1

#(set -o igncr) 2>/dev/null && set -o igncr; # cygwin specific shell options
#set -e
#set -x

SCRIPTS_LOGS_ROOT=.

# no local logging if nested call
(( ! IMPL_MODE && ! NEST_LVL )) && {
    export IMPL_MODE=1
    exec 3>&1 4>&2
    trap 'exec 2>&4 1>&3' EXIT HUP INT QUIT RETURN

    [[ ! -e "${SCRIPTS_LOGS_ROOT}/.log" ]] && mkdir "${SCRIPTS_LOGS_ROOT}/.log"

    # RANDOM instead of milliseconds
#    printf -v LOG_FILE_NAME_SUFFIX "%(%Y_%m_%d_%H_%M_%S_)T$(( RANDOM % 1000 ))" -1
    printf -v LOG_FILE_NAME_SUFFIX "%(%Y_%m_%d)T" -1
    (
    (

#     ____     __   __        ____
#    / __/__  / /__/ /__ ____/ __/_ _____  ____
#   / _// _ \/ / _  / -_) __/\ \/ // / _ \/ __/
#  /_/  \___/_/\_,_/\__/_/ /___/\_, /_//_/\__/
#                              /___/

###########################
# functions
###########################

# shellcheck disable=SC2034
# for (( i = 30; i < 38; i++ )); do echo -e "\033[0;"$i"m Normal: (0;$i); \033[1;"$i"m Light: (1;$i)"; done
r='\033[1;31m'
g='\033[1;32m'
y='\033[1;33m'
b='\033[1;34m'
c='\033[1;35m'
b2='\033[1;36m'
s='\033[0;37m'

#exec 3>&1 4>&2 #set up extra file descriptors
function catch-stderr() {
    local -n v="$1";
    shift && { v="$("$@" 2>&1 1>&3 3>&-)"; } 3>&1;
    echo "$v"
}

function catch-stderr2() {
    local err=''
    { err="$("$@" 2>&1 1>&3 3>&-)"; } 3>&1

    if [ "$err" != '' ]
    then
        echo "$err"
        return 1
    else
        return 0
    fi
}

function usage() {
    [ "$1" = "" ] || echo -e "\n\t${r}ERROR: \"$1\" is a required argument but is missing or is invalid${s}"
    echo -e "Usage: folder-sync start | stop [options]

        Options:
        < -s | --source >  < -d | --dest >  < -u | --user >  < -p | --password >
        [ -m | --marker ] [ -R ] [ -v ] [ -q ] [ -b ]
        Type 'folder-sync --help' for more information."
    exit 2
}

function help {
   echo -e "${s}
    Monitors an FTP directory and downloads all new _files as per the provided options.

    Note that there are three options for identifying \"new\" _files:
        1. Any file newer that the last file downloaded in the destination directory
        2. Any file newer than the script start time if there are no _files in the destination directory
        3. Any file newer than the time marker provided with the -m option e.g. -m \"yesterday\"
            see GNU documentation for all accepted formats:
            https://www.gnu.org/software/coreutils/manual/html_node/Date-input-formats.html#Date-input-formats

    To continuously download new _files, use the -b option

    Usage:

    Commands:
        start   execute the script
        stop    stop the background process (applicable only for -b option)

    Required:
        -s , --source     set the FTP source URL (with port if not using 21) along with the path i.e. \"ftp://192.168.1.1/ftp/root/_files\"
        -d , --dest       set the destination directory
        -u , --user       set user name

    Optional:
        -p , --password   set the password. If omitted, the script will ask for it on the console
        -m , --marker     custom cut-off time marker
        -l , --logfile    log file
        -R                when provided will delete the file from the source location
        -v                show verbose output
        -q                don't show any output
        -b                run in the background"
  exit 0
}

# shellcheck disable=SC2034
parseArgs() {
    declare -n __cmdargs=$1
    declare -n __argsmap=$2

    local flags="hvqRb:s:d:u:p:m:l:"
    local ops="start,stop,help,source:,dest:,user:,password:,marker:logfile:"

    __parsed=$(getopt -a -n folder_sync -o "$flags" --long "$ops" -- "${__cmdargs[@]}")
    [ $? -ne 0 ] && usage

    eval set -- "$__parsed"
    while :
    do
      case "$1" in
        # flags
        -R ) __argsmap[REM_FILE]="y" ; shift ;;
        -v ) __argsmap[LEVEL]=3      ; shift ;;
        -q ) __argsmap[LEVEL]=1      ; shift ;;
        --start ) __argsmap[CMD]="START"; shift ;;
        --stop ) stop ;;

        # options
        -h | --help) help ;;
        -s | --source)   __argsmap[URL]=$2  ; shift 2 ;;
        -d | --dest)     __argsmap[DEST]=$2 ; shift 2 ;;
        -u | --user)     __argsmap[USER]=$2 ; shift 2 ;;
        -p | --password) __argsmap[PWD]=$2  ; shift 2 ;;
        -l | --logfile)  __argsmap[LOG]=$2  ; shift 2 ;;
        -b ) __argsmap[SERVICE]=1; __argsmap[SLEEP]=$2; shift 2 ;;
        -m | --marker)   __argsmap[MARKER]=$(date -d "$2" '+%s'); shift 2 ;;
        --) shift; break ;;
        *) echo "Unexpected option: $1" ; usage ;;
      esac
    done
}

function stop {
    if [ "$(uname)" = "Linux" ]
    then
        killall -r folder-sync
    else
        #cygwin
        CYG_PID=$(procps -wwFAH | grep -v "grep" | grep "folder-sync" | cut -c 10-15)
        echo -e "Stopping CYGWIN PID(s)"
        echo "$CYG_PID"
        kill -s SIGTERM "$(procps -wwFAH | grep -v "grep" | grep "folder-sync"  | tr -s ' ' | cut -d ' ' -f 2)" 2>&1 /dev/null
    fi
}

#Cleanup on kill
function clean() {
    echo -e "${r}Download failed!${s} ERROR is [$1]"
    kill 0
    rm -Rf "$OUT_directory/wrk"
    exit 1
}

function runJob() {
    local job_pid=$1
    ({
        local err
        shift && { err="$("$@" 2>&1 1>&3 3>&-)"; } 3>&1;
        echo "$err"
        [ "$err" != '' ] && { echo "$err"; return 1; }
    }  ) &

    eval "$job_pid"="$!"
    return
}

function getPassword() {
    local __pwd="$1"
    local password

    echo -n "Enter password: "
    while IFS= read -p "$prompt" -r -s -n 1 char
    do
        if [[ $char == $'\0' ]] ; then
            break
        fi

        # handle backspace
        if [[ $char == $'\177' ]] ; then
            prompt=$'\b \b'
            password="${password%?}"
        else
            prompt='*'
            password+="$char"
        fi
    done

    eval "$__pwd"="$password"
    echo

    return
}

# get the file details and parse the size
function getSize() {
    local _size="$(curl -u "$USER:$PWD" -qIL "$1" 2> /dev/null | awk '/Length/ {print $2}'|grep -o '[0-9]*')"
    local _size=${_size:-1}
    echo "$_size"
    return
}

# takes an _array reference and updates it with the file names in the given directory
function getDirectoryContent() {
    local -n _arr=$1
    local _url="$2"

    #todo error checking & reporting
    # shellcheck disable=SC2034
    _arr=("$(curl -s -u "$USER:$PWD" "$_url/" | sed -nr 's/(^-[ rw-].*)( *)([0-9])(.*)/\4/p' | sed -e 's/^ //g' | sed -e 's/ /\ /g')")

    return
}

# returns the last modified time for the file provided in the URL
function getSourceLastModifiedDate() {
    local _dt=$(curl -s -I -u "$USER:$PWD" "$1" 2>&1 | awk '/Last-Modified:/ {sub("\r",""); print  $2,$3,$4,$5,$6,$7}')
    echo "$(date -d "${_dt}" '+%s')" # convert to ms
    return
}

function getTimeMarker() {
    local _latest=$(find "$1" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d ' ' -f 1)

    if [ -z ${_latest+_} ]; then
      echo "$(date '+%s')"
    else
      echo "$(date -d "@$_latest" '+%s')"
    fi

    return
}

# filters out any _files that are older than the _cutoff time
function getNewFiles() {
    # shellcheck disable=SC2178
    local -n _arr=$1
    local _url=$2
    local _cutoff=$3
    local _lmd

    # shellcheck disable=SC2068
    for f in ${_arr[@]}; do
        # echo "f: [$f]" # todo check file is not empty
        _lmd=$(getSourceLastModifiedDate "$_url/$f") #todo verify _lmd is not empty
        [ -n "$_lmd" ] || continue
        if [ "$_cutoff" -ge "$_lmd" ]; then
            print "\t(-) $f is old - skipped"
            _arr=("${_arr[@]/$f}") # remove old file
        else
          print "(+) $f is newer - downloading"
        fi
    done
    print ""
    return
}

function showProgress() {
    local action="$1"
    local directory="$2"
    local file_name="$3"
    local chunks="$4"
    local file_size="$5"
    local time="$6"
    local err="$7"

    local b=1
    local kb=1024
    local mb=1048576
    local gb=1073741824
    local units=$kb
    local scale="Kb"

    [[ $file_size -eq 0 ]] && return
    [[ $file_size -ge $mb ]] && { units=$kb; scale="Kb"; }
    [[ $file_size -ge $gb ]] && { units=$mb; scale="Mb"; }
    [[ $file_size -gt $gb ]] && { units=$gb; scale="Gb"; }

    local completed=$(( $(eval ls -l "$directory/$file_name.{1..$chunks}" 2> /dev/null | awk 'BEGIN{s=0}{s+=$5}END{print s}') ))
    local elapsed=$(( $(date +%s) - time ))
    local rate=$(( ( completed / elapsed )/units ))
    local pct=$(( ( completed*100 ) / file_size ))

    local status
    if [[ $pct -lt 100 ]]; then status="${y}Downloading${s}"; else status="${g}Completed${s}"; fi
    if [[ $action == 'Canceled' ]]; then status="${r}FAILED${s}"; fi

    printf  "%-15b" "$action"
    printf "%-30s" "$file_name"
    printf "%6s / %-6s @ %6s %3s/sec (%3s%%)" $((completed/units)) $((file_size/units)) $((rate)) $scale $pct
    printf "%-25b" "......$status"
    if [[ $action == 'Canceled' ]]; then printf "%40s" "[$err]"; fi
}

function download() {
    local SRC="$1"
    local DEST="$2"
    local NAME="$3"
    local size="$4"
    local SPLIT_NUM=1 # only needed when downloading in multiple parts

    WRK_directory="$DEST/wrk"
    mkdir -p "$WRK_directory" ; chmod 755 "$WRK_directory"
    [ -d "$OUT_directory" ] || { print "ERROR: Cannot create working directory [$WRK_directory]. Please check permissions"; exit; }

    # [[ $NAME == 'BCDriverMerge.exe' ]] && NAME='*BCDriverMerge.exe' # just for testing
    # curl --write-out "%{http_code}\n" -sS -R --ftp-pasv -u "$USER:$PWD" -o "${WRK_directory}/${NAME}.1" "$SRC/$NAME" >/dev/shm/fs 2>&1 &
    curl -sS -R --ftp-pasv -u "$USER:$PWD" -o "${WRK_directory}/${NAME}.1" "$SRC/$NAME" >/dev/shm/fs 2>&1 &

    # Wait for the job to complete while showing progress
    time=$(( $(date +%s)-1 ))
    while jobs | grep -q Running ;
    do
        sleep 1
        showProgress "Processing" "$WRK_directory" "$NAME" "$SPLIT_NUM" "$size" "$time"
        tput ech ${#_size} # erase the last reported size value
        tput cub 1000 # move 1000 chars left
    done


    read -r job_response < /dev/shm/fs # get the job actual output
    job_err=$(jobs | awk '/Exit/ {print $3}') # or another way to get just the exit code

    if [ "$job_err" == '' ]
    then
        showProgress 'Processed' "$WRK_directory" "$NAME" "$SPLIT_NUM" "$size" "$time"
    else
        showProgress 'Canceled' "$WRK_directory" "$NAME" "$SPLIT_NUM" "$size" "$time" "$job_response"
        ((ERR++))
    fi
    echo

    ERR_MSG=$(catch-stderr2 mv "${WRK_directory}/${NAME}.1" "$DEST/$NAME")
    [ $? -ne 0 ] && [ "$job_response" == '' ] && { print "$ERR_MSG"; ((ERR++)); }

    [ "$DELETE_REMOTE_FILE" = "y" ] && curl -u "$USER:$PWD" "$SRC" -Q"DELETE $SRC/$NAME" 2> /dev/null

    return "$ERR"
}

function print() {
  echo -e "$1 $2"
}

function checkAndDownload() {
    local _url="$1"
    local _time="$2"
    local _out="$3"
    local -a _files

    print ""
    print "Checking for new files as off [$(date -d @"$_time")] in [$_url]"
    getDirectoryContent _files "$_url"
    getNewFiles _files "$_url" "$_time"

    # shellcheck disable=SC2068
    for f in ${_files[@]}; do
        local _size=$(getSize "$_url/$f")
        download "$_url" "$_out" "$f" "$_size"
    done

    return
}

function main {
   echo "TBD"
}

###########################
# main
###########################

# shellcheck disable=SC2034
ERR=0
CMD_ARGS=("$@")
declare -A ARGS_MAP
parseArgs CMD_ARGS ARGS_MAP

#todo verbose option
#for K in "${!ARGS_MAP[@]}"; do echo "[$K] : [${ARGS_MAP[$K]}]"; done

# validate required arguments
[ ${ARGS_MAP[URL]+_} ] ||  usage "-s | --source"
[ ${ARGS_MAP[USER]+_} ] || usage "-u | --user"
[ ${ARGS_MAP[DEST]+_} ] || usage "-d | --dest"

URL="${ARGS_MAP[URL]}"
USER="${ARGS_MAP[USER]}"
DELETE_REMOTE_FILE=${ARGS_MAP[REM_FILE]:-"n"}
CMD=${ARGS_MAP[CMD]:-"START"}

# validate destination
OUT_directory=${ARGS_MAP[DEST]}
if [ ! -d "$OUT_directory" ]; then mkdir -p 755 "$OUT_directory"; chmod 0755 "$OUT_directory"; fi
[ -d "$OUT_directory" ] || usage "-d | --dest"

# use the provided time marker, _latest timestamp in the destination directory or current time (in this order)
CUT_OFF_TIME=${ARGS_MAP[MARKER]:-$(getTimeMarker "$OUT_directory")}

# verify password
PWD="${ARGS_MAP[PWD]}"
[ -n "$PWD" ] || getPassword PWD

# set service options
SERVICE=${ARGS_MAP[SERVICE]:-0}
SLEEP=${ARGS_MAP[SLEEP]:-60}

# set log level
LEVEL=${ARGS_MAP[LEVEL]:-2}
LOG=${ARGS_MAP[LOG]:-"$OUT_directory/log.txt"}

# todo: add verbose mode
#print "URL" "$URL"
#print "OUT_directory" "$OUT_directory"
#print "USER" "$USER"
#print "SERVICE" "$SERVICE"
#print "SLEEP" "$SLEEP"
#print "LEVEL" "$LEVEL"
#print "LOG" "$LOG"
#print "DELETE_REMOTE_FILE" "$DELETE_REMOTE_FILE"
#print "CUT_OFF_TIME" "$(date -d "@$CUT_OFF_TIME")"

## set trap commands
#trap clean SIGINT SIGTERM
#trap "exit" INT TERM ERR
#trap "kill 0" EXIT # terminated all jobs on exit


# logo
# todo: option for silent
echo -e ""
echo -e "${g}     ____     __   __       ${y} ____             ${s}"
echo -e "${g}    / __/__  / /__/ /__ ____${y}/ __/_ _____  ____${s}"
echo -e "${g}   / _// _ \/ / _  / -_) __/${y}\ \/ // / _ \/ __/${s}"
echo -e "${g}  /_/  \___/_/\_,_/\__/_/ ${y}/___/\_, /_//_/\__/ ${s}"
echo -e "${g}                          ${y}    /___/           ${s}"
echo -e ""

# shellcheck disable=SC2031
# shellcheck disable=SC2030
if [ "$SERVICE" -eq 1 ]
then
    echo -e "${g}Folder-sync started as background process; use '--stop' option to terminate it.${s}"
    { (
        while /bin/true; do
        checkAndDownload "$URL" "$CUT_OFF_TIME" "$OUT_directory"
        sleep "$SLEEP"

        CUT_OFF_TIME=$(getTimeMarker "$OUT_directory") #update time marker
#    done >>"$LOG" 2>&1 &
    done &); }>>"$LOG" 2>&1
else
    echo -e "${g}Folder-sync running...${s}"
    checkAndDownload "$URL" "$CUT_OFF_TIME" "$OUT_directory"
    if [[ ERR -eq 0 ]]
    then
        echo -e "${g}Folder-sync completed${s}"
    else
        echo -e "${y}Folder-sync completed with errors${s}"
    fi
    rm -Rf "$OUT_directory/wrk"
fi


# end of logging wrapper function
    # self script reentrance...
    exec $0 "$@"
    ) | tee -a "${SCRIPTS_LOGS_ROOT}/.log/folder-sync.${LOG_FILE_NAME_SUFFIX}.log" 2>&1
    ) 1>&3 2>&4

    exit $?
}

(( NEST_LVL++ ))