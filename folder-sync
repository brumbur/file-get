#!/bin/bash

#  Done:
#  1 - от къде да сваля
#  2 - къде да качва  (temp) или в папка на друга машина в мрежата
#  3 - ключ дали да трие сваленото (y/n)
#  4 - възможнжст за стартиране на повече от един скрипт едновремено
#
#  To do:
#  - като екстра за напреднали - да проверява за наличието на стринг в името на файла. Например " BG60" или "BG 60" или "BG_60". Ако има такъв стринг - да качи файла в друга папка (temp1)
#  $ ./folder-sync ftp://pesho:mzprx@192.168.1.1:21/remote/directory ./temp  y/n ("BG60","BG 60","BG_60") ./temp1


###########################
# functions
###########################

# for (( i = 30; i < 38; i++ )); do echo -e "\033[0;"$i"m Normal: (0;$i); \033[1;"$i"m Light: (1;$i)"; done
# Normal: (0;30);  Light: (1;30)
# Normal: (0;31);  Light: (1;31)
# Normal: (0;32);  Light: (1;32)
# Normal: (0;33);  Light: (1;33)
# Normal: (0;34);  Light: (1;34)
# Normal: (0;35);  Light: (1;35)
# Normal: (0;36);  Light: (1;36)
# Normal: (0;37);  Light: (1;37)

ansi_red='\033[1;31m'
ansi_blu='\033[1;34m'
ansi_yel='\033[1;33m'
ansi_cyn='\033[1;35m'
ansi_std='\033[0;37m'

function usage() {
    [ "$1" = "" ] || echo -e "\n\t${ansi_red}ERROR: \"$1\" is a required argument but is missing or is invalid${ansi_std}"
    echo -e "Usage: folder-sync start | stop [options]

        Options:
        < -s | --source >  < -d | --dest >  < -u | --user >  < -p | --password >
        [ -m | --marker ] [ -R ] [ -v ] [ -q ] [ -b ]
        Type 'folder-sync --help' for more information."
    exit 2
}

function help {
   echo -e "${ansi_std}
    Monitors an FTP directory and downloads all new files as per the provided options.

    Note that there are three options for identifying \"new\" files:
        1. Any file newer that the last file downloaded in the destination directory
        2. Any file newer than the script start time if there are no files in the destination directory
        3. Any file newer than the time marker provided with the -m option e.g. -m \"yesterday\"
            see GNU documentation for all accepted formats:
            https://www.gnu.org/software/coreutils/manual/html_node/Date-input-formats.html#Date-input-formats

    To continuously download new files, use the -b option

    Usage:

    Commands:
        start   execute the script
        stop    stop the background process (applicable only for -b option)

    Required:
        -s , --source     set the FTP source URL (with port if not using 21) along with the path i.e. \"ftp://192.168.1.1/ftp/root/files\"
        -d , --dest       set the destination directory
        -u , --user       set user name

    Optional:
        -p , --password   set the password. If omitted, the script will ask for it on the console
        -m , --marker     custom cut-off time marker
        -R                when provided will delete the file from the source location
        -v                show verbose output
        -q                don't show any output
        -b                run in the background"
  exit 0
}

parseArgs() {
    declare -n __cmdargs=$1
    declare -n __argsmap=$2

    local flags="hvqRb:s:d:u:p:m:"
    local ops="start,stop,help,source:,dest:,user:,password:,marker:"

    __parsed=$(getopt -a -n folder_sync -o "$flags" --long "$ops" -- "${__cmdargs[@]}")
    [ $? -ne 0 ] && usage

    printf "parsed args: [%s]\n" "${__parsed[@]}"

    eval set -- "$__parsed"
    while :
    do
      case "$1" in
        # flags
        -R ) __argsmap[REM_FILE]="y" ; shift ;;
        -v ) __argsmap[LEVEL]=3      ; shift ;;
        -q ) __argsmap[Level]=1      ; shift ;;
        --start ) __argsmap[CMD]="START"; shift ;;
        --stop )  __argsmap[CMD]="STOP" ; shift ;;

        # options
        -h | --help) help ;;
        -s | --source)   __argsmap[URL]=$2  ; shift 2 ;;
        -d | --dest)     __argsmap[DEST]=$2 ; shift 2 ;;
        -u | --user)     __argsmap[USER]=$2 ; shift 2 ;;
        -p | --password) __argsmap[PWD]=$2  ; shift 2 ;;
        -b ) __argsmap[SERVICE]=1; __argsmap[SLEEP]=$2; shift 2 ;;
        -m | --marker)   __argsmap[MARKER]=$(date -d "@$2" '+%s'); shift 2 ;;
        --) shift; break ;;
        *) echo "Unexpected option: $1" ; usage ;;
      esac
    done
}

function getPassword() {
    local __pwd="$1"
    local password

    echo -n "Enter password: "
    while IFS= read -p "$prompt" -r -s -n 1 char
    do
        if [[ $char == $'\0' ]] ; then
            break
        fi

        # handle backspace
        if [[ $char == $'\177' ]] ; then
            prompt=$'\b \b'
            password="${password%?}"
        else
            prompt='*'
            password+="$char"
        fi
    done

    eval "$__pwd"="$password"
    echo

    return
}

#Cleanup on kill
function clean {
  print "${ansi_red}Download failed! Cleaning..."
  kill 0
  rm -Rf "$OUT_DIR/wrk"
  exit 1
}

# get the file details and parse the size
function getSize() {
    local __size
    __size="$(curl -u "$USER:$PWD" -qIL $1 2> /dev/null | awk '/Length/ {print $2}'|grep -o '[0-9]*')"
    local __size=${__size:-1}
    echo "$__size"
    return
}

# takes an array reference and updates it with the file names in the given directory
function getDirectoryContent() {
    local -n arr=$1
    local url="$2"

    print "curl -s -u $USER:$PWD $url"
    arr=("$(curl -s -u "$USER:$PWD" "$url" | sed -nr 's/(^-[ rw-].*)( *)([0-9])(.*)/\4/p' | sed -e 's/^ //g' | sed -e 's/ /\ /g')")

    if [ $? -eq 0 ]
        then
        echo ""
    else
        echo "ERROR: $?" >&2
        clean
    fi

    return
}

# takes the complete URL as argument and returns the last modified time
function getSourceLastModifiedDate() {
    local dt=$(curl -I -u "$USER:$PWD" "$1" 2>&1 | awk '/Last-Modified:/ {sub("\r",""); print  $2,$3,$4,$5,$6,$7}')
    local ms="$(date -d "${dt}" '+%s')" # convert to ms
    echo "$ms"
    return
}

function getDestinationLastModifiedDate() {
    local destDir=$1
    local last=$(find $destDir -type f -printf '%T@ %p\n' | sort -n | tail -1)

    [ -n "$last" ] || return

    file=(${last// / })

    echo "$(date -d "@${file[0]}" '+%s')"
    return
}

function getTimeMarker() {
    local latest=$(find "$1" -type f -printf '%T@ %p\n' | sort -n | tail -1)

    if [ -z ${latest+_} ]; then
      echo $(date '+%s')
    else
      file=(${latest// / })
      echo $(date -d "@${file[0]}" '+%s')
    fi

    return
}

# filters out any files that are older than the cutoff time
function getNewFiles() {
    local -n __arr=$1
    local url=$2
    local cutoff=$3
    local lmd

    print "Checking location" "$url"

    for f in "${__arr[@]}"; do
        echo "f: [$f]" # todo check file is not empty
        lmd=$(getSourceLastModifiedDate "$url/$f") #todo verify lmd is not empty
        echo "LMD: $lmd"
        [ -n "$lmd" ] || continue
        if [ "$cutoff" -ge "$lmd" ]; then
            print "\t(-) $f is old" "skipped"
            __arr=("${__arr[@]/$f}") # remove old file
        else
          print "\t(+) $f is newer" "downloading"
        fi
    done
    return
}

function calcProgress() {
        # local FNAME=$1
        # local PARTNUM=$2
        # local SZ=$3
        # local T=$4

        [[ $3 -eq 0 ]] && return

        local GOT__size=$((`eval ls -l "$1".{1..$2} 2> /dev/null | awk 'BEGIN{SUM=0}{SUM=SUM+$5}END{print SUM}'`))
        local TIMEDIFF=$(( `date +%s` - $4 ))
        local RATE=$(( ($GOT__size / $TIMEDIFF)/1024 ))
        local PCT=$(( ($GOT__size*100) / $3 ))

        echo  "Downloading $1 in $2 parts: $(($GOT__size/1048576)) / $(($3/1048576)) mb @ $(($RATE)) KB/s ($PCT%).    "
#        local progress_msg
#        progress_msg="Downloading $1 in $2 parts: $(($GOT__size/1048576)) / $(($3/1048576)) mb @ $(($RATE)) KB/s ($PCT%).    "
#        echo "$progress_msg"
#        tput ech ${#__size} # erase the last reported size value
#        tput cub 1000 # move 1000 chars left

  return
}

function download() {
    local SRC="$1"
    local DEST="$2"
    local NAME="$3"
    local __size=$4
    local SPLIT_NUM=1 # only needed when downloading in multiple parts

    WRK_DIR="$DEST/wrk"
    mkdir -p "$WRK_DIR" ; chmod 755 "$WRK_DIR"
    [ -d "$OUT_DIR" ] || print "ERROR: Cannot create working directory [$WRK_DIR]. Please check destination permissions"

    echo "curl -R --ftp-pasv -u $USER:$PWD -o ${WRK_DIR}/${NAME}.1 $SRC/$NAME"
    curl -R --ftp-pasv -u "$USER:$PWD" -o "${WRK_DIR}/${NAME}.1" "$SRC/$NAME" 2> /dev/null &

    # Wait for the job to complete while showing progress
    TIME=$(( $(date +%s)-1 ))
    while jobs | grep -q Running ;
    do
#        echo -n "$(calcProgress "${WRK_DIR}/${NAME}.1" "$SPLIT_NUM" "$__size" "$TIME")"
#        tput ech ${#__size} # erase the last reported size value
#        tput cub 1000 # move 1000 chars left
        sleep 1
    done

#    echo "$(calcProgress "${WRK_DIR}/${NAME}.1" "$SPLIT_NUM" "$__size ""$TIME")"

    mv "${WRK_DIR}/${NAME}.1" "$DEST/$NAME"

    if [ $? -eq 0 ]
    then
        local file_path
        file_path=$(echo "$SRC" | cut -d@ -f2 | cut -d/ -f2- | cut -d? -f1)
        [ "$DELETE_REMOTE_FILE" = "y" ] && curl -u "$USER:$PWD" "$SRC" -Q"DELE $file_path/$NAME" 2> /dev/null
        echo "Download completed! Check file in $DEST"
    else
        echo "Could not download file: $?" >&2
        clean
    fi
}

function print() {
  echo -e "$1 [$2]"
}

function checkAndDownload() {
    local __url="$1"
    local __time="$2"
    local __out="$3"
    local -a files

    print "Checking for new files as off [$(date -d @$__time)] in [$__url]"
    getDirectoryContent files "$__url"
    print "Found: " "${files[@]}"
    getNewFiles files "$__url" "$__time"
    print "New files to download: " "${files[@]}"

    for f in ${files[@]}; do
        local __size=$(getSize "$__url/$f")
        echo "Downloading $f with size $__size"
        download "$__url" "$__out" "$f" "$__size"
    done
    print "Done!"

    return
}

# cygwin needs to have procps-ng package to support pgrep (https://cygwin.com/packages/summary/procps-ng.html)
function getcpid() {
    cpids=`pgrep -P $1|xargs`

    for cpid in $cpids;
    do
        echo "$cpid"
        getcpid $cpid
    done
}

###########################
# main
###########################

CMD_ARGS=("$@")
declare -A ARGS_MAP
parseArgs CMD_ARGS ARGS_MAP
for K in "${!ARGS_MAP[@]}"; do echo "[$K] : [${ARGS_MAP[$K]}]"; done

# validate required arguments
[ ${ARGS_MAP[URL]+_} ] ||  usage "-s | --source"
[ ${ARGS_MAP[USER]+_} ] || usage "-u | --user"
[ ${ARGS_MAP[DEST]+_} ] || usage "-d | --dest"

URL="${ARGS_MAP[URL]}"
USER="${ARGS_MAP[USER]}"
DELETE_REMOTE_FILE=${ARGS_MAP[REM_FILE]:-"n"}

# validate destination
OUT_DIR=${ARGS_MAP[DEST]}
if [ ! -d "$OUT_DIR" ]; then mkdir -p 755 "$OUT_DIR"; chmod 0755 "$OUT_DIR"; fi
[ -d "$OUT_DIR" ] || usage "-d | --dest"

# use the provided time marker, latest timestamp in the destination directory or current time (in this order)
CUT_OFF_TIME=${ARGS_MAP[MARKER]:-$(getTimeMarker "$OUT_DIR")}

# verify password
PWD="${ARGS_MAP[PWD]}"
[ -n "$PWD" ] || getPassword PWD

# set service options
SERVICE=${ARGS_MAP[SERVICE]:-0}
SLEEP=${ARGS_MAP[SLEEP]:-60}

# set log level
LEVEL=${ARGS_MAP[LEVEL]:-2}

# todo: add verbose mode
print "URL" "$URL"
print "OUT_DIR" "$OUT_DIR"
print "USER" "$USER"
print "SERVICE" "$SERVICE"
print "SLEEP" "$SLEEP"
print "LEVEL" "$LEVEL"
print "DELETE_REMOTE_FILE" "$DELETE_REMOTE_FILE"
print "CUT_OFF_TIME" "$(date -d "@$CUT_OFF_TIME")"

# set trap commands
trap clean SIGINT SIGTERM
trap "exit" INT TERM ERR
trap "kill 0" EXIT

# start process
#declare -a files

# background loop
#while :
#do
    checkAndDownload "$URL" "$CUT_OFF_TIME" "$OUT_DIR"
#    print "Checking for new files as off" "$(date -d "@$CUT_OFF_TIME")"
#    getDirectoryContent files "$URL"
#    getNewFiles files "$URL" "$CUT_OFF_TIME"
#
#    for NAME in ${files[@]}; do
#        FILE___size=$(getSize "$URL/$f")
#        echo "Downloading $NAME with size $FILE___size"
#        download "$URL" "$OUT_DIR" "$NAME" "$FILE___size"
#    done

#    rm -Rf "$OUT_DIR/wrk"
    sleep "$SLEEP"
    CUT_OFF_TIME=$(getTimeMarker "$OUT_DIR")
    echo "Finished sync. Exiting."
#done

rm -Rf "$OUT_DIR/wrk"

# cygwin needs to have procps-ng package to support pgrep (https://cygwin.com/packages/summary/procps-ng.html)
#echo "$BASHPID Started the job with PID $(getcpid $BASHPID)"

# cygwin does not support ps -x
#echo "PPID `ps -axf | grep $BASHPID`"

echo "Parent PID [$BASHPID] will wait on the background job"
echo "To STOP use Ctrl-C"