#!/bin/bash
#set -e

#     ____     __   __        ____
#    / __/__  / /__/ /__ ____/ __/_ _____  ____
#   / _// _ \/ / _  / -_) __/\ \/ // / _ \/ __/
#  /_/  \___/_/\_,_/\__/_/ /___/\_, /_//_/\__/
#                              /___/
#

###########################
# functions
###########################

# shellcheck disable=SC2034
# for (( i = 30; i < 38; i++ )); do echo -e "\033[0;"$i"m Normal: (0;$i); \033[1;"$i"m Light: (1;$i)"; done
ansi_red='\033[1;31m'
ansi_grn='\033[1;32m'
ansi_yel='\033[1;33m'
ansi_blu='\033[1;34m'
ansi_cyn='\033[1;35m'
ansi_bl2='\033[1;36m'
ansi_std='\033[0;37m'

#trap "error reported  ${LINENO}" ERR
exec 3>&1 4>&2 #set up extra file descriptors

#{ ERR_MSG="$( { mv "${WRK_DIR}/${NAME}.2" "$DEST/$NAME"; } 2>&1 1>&3 3>&- )"; } 3>&1;
function catch-stderr() {
    local -n v="$1";
    shift && { v="$("$@" 2>&1 1>&3 3>&-)"; } 3>&1;
}

function catch-stderr2() {
    local err=''
    { err="$("$@" 2>&1 1>&3 3>&-)"; } 3>&1

    if [ "$err" != '' ]
    then
        echo "$err"
        return 1
    else
        return 0
    fi
}



function usage() {
    [ "$1" = "" ] || echo -e "\n\t${ansi_red}ERROR: \"$1\" is a required argument but is missing or is invalid${ansi_std}"
    echo -e "Usage: folder-sync start | stop [options]

        Options:
        < -s | --source >  < -d | --dest >  < -u | --user >  < -p | --password >
        [ -m | --marker ] [ -R ] [ -v ] [ -q ] [ -b ]
        Type 'folder-sync --help' for more information."
    exit 2
}

function help {
   echo -e "${ansi_std}
    Monitors an FTP directory and downloads all new files as per the provided options.

    Note that there are three options for identifying \"new\" files:
        1. Any file newer that the last file downloaded in the destination directory
        2. Any file newer than the script start time if there are no files in the destination directory
        3. Any file newer than the time marker provided with the -m option e.g. -m \"yesterday\"
            see GNU documentation for all accepted formats:
            https://www.gnu.org/software/coreutils/manual/html_node/Date-input-formats.html#Date-input-formats

    To continuously download new files, use the -b option

    Usage:

    Commands:
        start   execute the script
        stop    stop the background process (applicable only for -b option)

    Required:
        -s , --source     set the FTP source URL (with port if not using 21) along with the path i.e. \"ftp://192.168.1.1/ftp/root/files\"
        -d , --dest       set the destination directory
        -u , --user       set user name

    Optional:
        -p , --password   set the password. If omitted, the script will ask for it on the console
        -m , --marker     custom cut-off time marker
        -l , --logfile    log file
        -R                when provided will delete the file from the source location
        -v                show verbose output
        -q                don't show any output
        -b                run in the background"
  exit 0
}

# shellcheck disable=SC2034
parseArgs() {
    declare -n __cmdargs=$1
    declare -n __argsmap=$2

    local flags="hvqRb:s:d:u:p:m:l:"
    local ops="start,stop,help,source:,dest:,user:,password:,marker:logfile:"

    __parsed=$(getopt -a -n folder_sync -o "$flags" --long "$ops" -- "${__cmdargs[@]}")
    [ $? -ne 0 ] && usage

#    printf "parsed args: [%s]\n" "${__parsed[@]}"

    eval set -- "$__parsed"
    while :
    do
      case "$1" in
        # flags
        -R ) __argsmap[REM_FILE]="y" ; shift ;;
        -v ) __argsmap[LEVEL]=3      ; shift ;;
        -q ) __argsmap[LEVEL]=1      ; shift ;;
        --start ) __argsmap[CMD]="START"; shift ;;
        --stop ) stop ;;

        # options
        -h | --help) help ;;
        -s | --source)   __argsmap[URL]=$2  ; shift 2 ;;
        -d | --dest)     __argsmap[DEST]=$2 ; shift 2 ;;
        -u | --user)     __argsmap[USER]=$2 ; shift 2 ;;
        -p | --password) __argsmap[PWD]=$2  ; shift 2 ;;
        -l | --logfile)  __argsmap[LOG]=$2  ; shift 2 ;;
        -b ) __argsmap[SERVICE]=1; __argsmap[SLEEP]=$2; shift 2 ;;
        -m | --marker)   __argsmap[MARKER]=$(date -d "$2" '+%s'); shift 2 ;;
        --) shift; break ;;
        *) echo "Unexpected option: $1" ; usage ;;
      esac
    done
}

function stop {
    if [ "$(uname)" = "Linux" ]
    then
        killall -r folder-sync
    else
        #cygwin
        CYGPID=$(procps -wwFAH | grep -v "grep" | grep "folder-sync" | cut -c 10-15)
        echo -e "Stopping CYGWIN PID(s)"
        echo "$CYGPID"
        kill -s SIGTERM $(procps -wwFAH | grep -v "grep" | grep "folder-sync"  | tr -s ' ' | cut -d ' ' -f 2) 2>&1 /dev/null
    fi
}

#Cleanup on kill
function clean() {
    echo -e "${ansi_red}Download failed!${ansi_std} ERROR is [$1]"
    kill 0
    rm -Rf "$OUT_DIR/wrk"
    exit 1
}

function getPassword() {
    local __pwd="$1"
    local password

    echo -n "Enter password: "
    while IFS= read -p "$prompt" -r -s -n 1 char
    do
        if [[ $char == $'\0' ]] ; then
            break
        fi

        # handle backspace
        if [[ $char == $'\177' ]] ; then
            prompt=$'\b \b'
            password="${password%?}"
        else
            prompt='*'
            password+="$char"
        fi
    done

    eval "$__pwd"="$password"
    echo

    return
}

# get the file details and parse the size
function getSize() {
    local __size
    __size="$(curl -u "$USER:$PWD" -qIL "$1" 2> /dev/null | awk '/Length/ {print $2}'|grep -o '[0-9]*')"
    local __size=${__size:-1}
    echo "$__size"
    return
}

# takes an array reference and updates it with the file names in the given directory
function getDirectoryContent() {
    local -n arr=$1
    local url="$2"

    # shellcheck disable=SC2034
    arr=("$(curl -s -u "$USER:$PWD" "$url/" | sed -nr 's/(^-[ rw-].*)( *)([0-9])(.*)/\4/p' | sed -e 's/^ //g' | sed -e 's/ /\ /g')")

    return
}

# returns the last modified time for the file provided in the URL
function getSourceLastModifiedDate() {
    local dt
    dt=$(curl -I -u "$USER:$PWD" "$1" 2>&1 | awk '/Last-Modified:/ {sub("\r",""); print  $2,$3,$4,$5,$6,$7}')
    echo "$(date -d "${dt}" '+%s')" # convert to ms
    return
}

function getTimeMarker() {
    local latest
    latest=$(find "$1" -type f -printf '%T@ %p\n' | sort -n | tail -1 | cut -d ' ' -f 1)

    if [ -z ${latest+_} ]; then
      echo "$(date '+%s')"
    else
      echo "$(date -d "@$latest" '+%s')"
    fi

    return
}

# filters out any files that are older than the cutoff time
function getNewFiles() {
    local -n __arr=$1
    local url=$2
    local cutoff=$3
    local lmd

    print "Checking location" "$url"

    # shellcheck disable=SC2068
    for f in ${__arr[@]}; do
        #echo "f: [$f]" # todo check file is not empty
        lmd=$(getSourceLastModifiedDate "$url/$f") #todo verify lmd is not empty
        [ -n "$lmd" ] || continue
        if [ "$cutoff" -ge "$lmd" ]; then
            print "\t(-) $f is old - skipped"
            __arr=("${__arr[@]/$f}") # remove old file
        else
          print "\t(+) $f is newer - downloading"
        fi
    done
    return
}

# shellcheck disable=SC2086
# shellcheck disable=SC2175
function calcProgress() {
        local action="$1"
        local DIR="$2"
        local FILE_NAME="$3"
        local CHUNKS="$4"
        local FILE_SIZE="$5"
        local TIME="$6"

        local b=1
        local kb=1024
        local mb=1048576
        local gb=1073741824
        local units=$kb
        local scale="Kb"

        [[ $FILE_SIZE -eq 0 ]] && return
        [[ $FILE_SIZE -ge $mb ]] && { units=$kb; scale="Kb"; }
        [[ $FILE_SIZE -ge $gb ]] && { units=$mb; scale="Mb"; }
        [[ $FILE_SIZE -gt $gb ]] && { units=$gb; scale="Gb"; }

        local COMPLETED=$(( $(eval ls -l $DIR/$FILE_NAME.{1..$CHUNKS} 2> /dev/null | awk 'BEGIN{SUM=0}{SUM=SUM+$5}END{print SUM}') ))
        local ELAPSED=$(( $(date +%s) - TIME ))
        local RATE=$(( ( COMPLETED / ELAPSED )/units ))
        local PCT=$(( ( COMPLETED*100 ) / FILE_SIZE ))
        local STATUS
        if [[ $PCT -lt 100 ]]; then STATUS="...${ansi_yel}Downloading${ansi_std}"; else STATUS="...${ansi_grn}Completed${ansi_std}"; fi

        local msg="$action $FILE_NAME in $CHUNKS part(s): $((COMPLETED/units)) / $((FILE_SIZE/units)) $scale @ $((RATE)) $scale/s ($PCT%).......$STATUS"
        echo -en "$msg"
#        tput ech ${#__size} # erase the last reported size value
#        tput cub 1000 # move 1000 chars left
  return
}

function download() {
    local SRC="$1"
    local DEST="$2"
    local NAME="$3"
    local size="$4"
    local SPLIT_NUM=1 # only needed when downloading in multiple parts

    WRK_DIR="$DEST/wrk"
    mkdir -p "$WRK_DIR" ; chmod 755 "$WRK_DIR"
    [ -d "$OUT_DIR" ] || print "ERROR: Cannot create working directory [$WRK_DIR]. Please check destination permissions"

    curl -R --ftp-pasv -u "$USER:$PWD+" -o "${WRK_DIR}/${NAME}.1" "$SRC/$NAME" 2> /dev/null &
#    [ $? -ne 0 ] && clean "$ERR_MSG"

#    echo "Job details: $(jobs -x)"

    # Wait for the job to complete while showing progress
    TIME=$(( $(date +%s)-1 ))
    echo
    while jobs | grep -q Running ;
    do
        sleep 1
        calcProgress "Downloading" "$WRK_DIR" "$NAME" "$SPLIT_NUM" "$size" "$TIME"
        tput ech ${#__size} # erase the last reported size value
        tput cub 1000 # move 1000 chars left
    done

    calcProgress "Completed"  "$WRK_DIR" "$NAME" "$SPLIT_NUM" "$size" "$TIME"
    echo
    echo "Job $(jobs)"

    ERR_MSG=$(catch-stderr2 mv "${WRK_DIR}/${NAME}.1" "$DEST/$NAME")

    [ $? -ne 0 ] && clean "$ERR_MSG"

    [ "$DELETE_REMOTE_FILE" = "y" ]  && curl -u "$USER:$PWD" "$SRC" -Q"DELE $file_path/$NAME" 2> /dev/null
}

function print() {
  echo -e "$1 $2"
}

function checkAndDownload() {
    local __url="$1"
    local __time="$2"
    local __out="$3"
    local -a files

    print "Checking for new files as off [$(date -d @$__time)] in [$__url]"
    getDirectoryContent files "$__url"
#    print "Found: " "${files[@]}"
    getNewFiles files "$__url" "$__time"
#    print "New files to download: " "$(( ${#files[@]}-1 ))"

    # shellcheck disable=SC2068
    # shellcheck disable=SC2155
    for f in ${files[@]}; do
        local _size=$(getSize "$__url/$f")
        download "$__url" "$__out" "$f" "$_size"
    done

    return
}


###########################
# main
###########################

# shellcheck disable=SC2034
CMD_ARGS=("$@")
declare -A ARGS_MAP
parseArgs CMD_ARGS ARGS_MAP

#todo verbose option
for K in "${!ARGS_MAP[@]}"; do echo "[$K] : [${ARGS_MAP[$K]}]"; done

# validate required arguments
[ ${ARGS_MAP[URL]+_} ] ||  usage "-s | --source"
[ ${ARGS_MAP[USER]+_} ] || usage "-u | --user"
[ ${ARGS_MAP[DEST]+_} ] || usage "-d | --dest"

URL="${ARGS_MAP[URL]}"
USER="${ARGS_MAP[USER]}"
DELETE_REMOTE_FILE=${ARGS_MAP[REM_FILE]:-"n"}
CMD=${ARGS_MAP[CMD]:-"START"}

# validate destination
OUT_DIR=${ARGS_MAP[DEST]}
if [ ! -d "$OUT_DIR" ]; then mkdir -p 755 "$OUT_DIR"; chmod 0755 "$OUT_DIR"; fi
[ -d "$OUT_DIR" ] || usage "-d | --dest"

# use the provided time marker, latest timestamp in the destination directory or current time (in this order)
CUT_OFF_TIME=${ARGS_MAP[MARKER]:-$(getTimeMarker "$OUT_DIR")}

# verify password
PWD="${ARGS_MAP[PWD]}"
[ -n "$PWD" ] || getPassword PWD

# set service options
SERVICE=${ARGS_MAP[SERVICE]:-0}
SLEEP=${ARGS_MAP[SLEEP]:-60}

# set log level
LEVEL=${ARGS_MAP[LEVEL]:-2}
LOG=${ARGS_MAP[LOG]:-"$OUT_DIR/log.txt"}

# todo: add verbose mode
#print "URL" "$URL"
#print "OUT_DIR" "$OUT_DIR"
#print "USER" "$USER"
#print "SERVICE" "$SERVICE"
#print "SLEEP" "$SLEEP"
#print "LEVEL" "$LEVEL"
#print "LOG" "$LOG"
#print "DELETE_REMOTE_FILE" "$DELETE_REMOTE_FILE"
#print "CUT_OFF_TIME" "$(date -d "@$CUT_OFF_TIME")"

## set trap commands
#trap clean SIGINT SIGTERM
#trap "exit" INT TERM ERR
#trap "kill 0" EXIT # terminated all jobs on exit


# logo
# todo: option for silent
echo -e ""
echo -e "${ansi_grn}     ____     __   __       ${ansi_yel} ____             ${ansi_std}"
echo -e "${ansi_grn}    / __/__  / /__/ /__ ____${ansi_yel}/ __/_ _____  ____${ansi_std}"
echo -e "${ansi_grn}   / _// _ \/ / _  / -_) __/${ansi_yel}\ \/ // / _ \/ __/${ansi_std}"
echo -e "${ansi_grn}  /_/  \___/_/\_,_/\__/_/ ${ansi_yel}/___/\_, /_//_/\__/ ${ansi_std}"
echo -e "${ansi_grn}                          ${ansi_yel}    /___/           ${ansi_std}"
echo -e ""

# shellcheck disable=SC2031
# shellcheck disable=SC2030
if [ "$SERVICE" -eq 1 ]
then
    echo -e "${ansi_grn}Folder-sync started as background process; use '--stop' option to terminate it.${ansi_std}"
    { (
        while /bin/true; do
        checkAndDownload "$URL" "$CUT_OFF_TIME" "$OUT_DIR"
        sleep "$SLEEP"

        CUT_OFF_TIME=$(getTimeMarker "$OUT_DIR") #update time marker
#    done 2>&1>>"$LOG" &
    done &); }  2>&1>>"$LOG"
else
    echo -e "${ansi_grn}Folder-sync running...${ansi_std}"
    checkAndDownload "$URL" "$CUT_OFF_TIME" "$OUT_DIR"
    echo -e "${ansi_grn}Folder-sync completed${ansi_std}"
    rm -Rf "$OUT_DIR/wrk"
fi